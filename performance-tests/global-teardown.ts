/**
 * Global teardown for performance testing
 * Generates final performance reports and cleanup
 */

import { FullConfig } from '@playwright/test';

async function globalTeardown(config: FullConfig) {
  console.log('\nüìä Generating performance test summary...\n');
  
  // Generate performance report
  await generatePerformanceReport();
  
  // Analyze performance data
  await analyzePerformanceResults();
  
  // Cleanup temporary data
  await cleanupTempData();
  
  console.log('‚úÖ Performance testing completed\n');
}

/**
 * Generate comprehensive performance report
 */
async function generatePerformanceReport() {
  console.log('üìã Generating performance report...');
  
  const fs = require('fs');
  const path = require('path');
  
  try {
    const perfDataDir = path.join(process.cwd(), 'performance-test-data');
    const reportFile = path.join(perfDataDir, 'performance-report.md');
    
    // Read performance data
    const baselineFile = path.join(perfDataDir, 'baseline.json');
    const perfLogFile = path.join(perfDataDir, 'performance-log.jsonl');
    
    let baseline = {};
    let performanceLogs = [];
    
    if (fs.existsSync(baselineFile)) {
      baseline = JSON.parse(fs.readFileSync(baselineFile, 'utf8'));
    }
    
    if (fs.existsSync(perfLogFile)) {
      const logData = fs.readFileSync(perfLogFile, 'utf8');
      performanceLogs = logData.split('\n')
        .filter(line => line.trim())
        .map(line => JSON.parse(line));
    }
    
    // Read test results if available
    let testResults = {};
    const testResultsFile = path.join(process.cwd(), 'performance-test-results.json');
    if (fs.existsSync(testResultsFile)) {
      testResults = JSON.parse(fs.readFileSync(testResultsFile, 'utf8'));
    }
    
    // Read bundle analysis if available
    let bundleResults = {};
    const bundleResultsFile = path.join(process.cwd(), 'bundle-analysis-results.json');
    if (fs.existsSync(bundleResultsFile)) {
      bundleResults = JSON.parse(fs.readFileSync(bundleResultsFile, 'utf8'));
    }
    
    // Generate report
    const report = generateMarkdownReport(baseline, performanceLogs, testResults, bundleResults);
    
    fs.writeFileSync(reportFile, report);
    console.log(`  ‚úì Performance report saved: ${reportFile}`);
    
  } catch (error) {
    console.error('  ‚ùå Failed to generate performance report:', error.message);
  }
}

/**
 * Generate markdown performance report
 */
function generateMarkdownReport(baseline: any, logs: any[], testResults: any, bundleResults: any): string {
  const timestamp = new Date().toISOString();
  
  return `
# Performance Test Report

**Generated:** ${timestamp}  
**Test Session:** ${baseline.testSession || 'unknown'}  
**Environment:** ${baseline.environment?.ci ? 'CI' : 'Local'}

## Executive Summary

${generateExecutiveSummary(testResults, bundleResults)}

## Test Results Overview

${generateTestResultsSection(testResults)}

## Bundle Analysis

${generateBundleAnalysisSection(bundleResults)}

## Performance Budgets

${generateBudgetComplianceSection(baseline, testResults, bundleResults)}

## Recommendations

${generateRecommendationsSection(testResults, bundleResults)}

## Raw Performance Data

${generateRawDataSection(logs)}

---
*Report generated by Driplo Performance Testing Suite*
`;
}

/**
 * Generate executive summary section
 */
function generateExecutiveSummary(testResults: any, bundleResults: any): string {
  const testsPassed = testResults.suites ? 
    testResults.suites.reduce((acc: number, suite: any) => acc + (suite.specs?.filter((spec: any) => spec.ok).length || 0), 0) : 0;
  
  const testsTotal = testResults.suites ?
    testResults.suites.reduce((acc: number, suite: any) => acc + (suite.specs?.length || 0), 0) : 0;
  
  const bundleWithinBudget = bundleResults.totals ? bundleResults.totals.withinBudget : 'Unknown';
  const bundleSize = bundleResults.totals ? `${bundleResults.totals.size.toFixed(1)}KB` : 'Unknown';
  
  return `
- **Test Success Rate:** ${testsTotal > 0 ? `${testsPassed}/${testsTotal} (${((testsPassed / testsTotal) * 100).toFixed(1)}%)` : 'No tests run'}
- **Bundle Budget Status:** ${bundleWithinBudget ? '‚úÖ PASS' : '‚ùå FAIL'}
- **Total Bundle Size:** ${bundleSize}
- **CLAUDE.md Compliance:** ${bundleWithinBudget && testsPassed === testsTotal ? '‚úÖ COMPLIANT' : '‚ùå NON-COMPLIANT'}
`;
}

/**
 * Generate test results section
 */
function generateTestResultsSection(testResults: any): string {
  if (!testResults.suites) {
    return 'No test results available.';
  }
  
  let section = '';
  
  testResults.suites.forEach((suite: any) => {
    section += `\n### ${suite.title}\n\n`;
    
    if (suite.specs) {
      suite.specs.forEach((spec: any) => {
        const status = spec.ok ? '‚úÖ' : '‚ùå';
        const duration = spec.tests?.[0]?.results?.[0]?.duration || 0;
        section += `- ${status} ${spec.title} (${duration}ms)\n`;
      });
    }
  });
  
  return section;
}

/**
 * Generate bundle analysis section
 */
function generateBundleAnalysisSection(bundleResults: any): string {
  if (!bundleResults.components) {
    return 'No bundle analysis results available.';
  }
  
  let section = `
| Component | Size | Budget | Status |
|-----------|------|--------|--------|
`;
  
  Object.entries(bundleResults.components).forEach(([name, data]: [string, any]) => {
    const status = data.withinBudget ? '‚úÖ' : '‚ùå';
    section += `| ${name} | ${data.size.toFixed(1)}KB | ${data.budget}KB | ${status} |\n`;
  });
  
  section += `\n**Total Bundle:** ${bundleResults.totals.size.toFixed(1)}KB / ${bundleResults.totals.budget}KB (${bundleResults.totals.withinBudget ? '‚úÖ PASS' : '‚ùå FAIL'})\n`;
  
  if (bundleResults.violations && bundleResults.violations.length > 0) {
    section += '\n**Budget Violations:**\n';
    bundleResults.violations.forEach((violation: any) => {
      section += `- ${violation.name}: +${violation.overhead.toFixed(1)}KB over budget\n`;
    });
  }
  
  return section;
}

/**
 * Generate budget compliance section
 */
function generateBudgetComplianceSection(baseline: any, testResults: any, bundleResults: any): string {
  if (!baseline.budgets) {
    return 'No performance budgets defined.';
  }
  
  let section = `
| Metric | Budget | Status |
|--------|--------|--------|
`;
  
  Object.entries(baseline.budgets).forEach(([metric, budget]: [string, any]) => {
    // This would need to be populated with actual test results
    // For now, showing budget structure
    section += `| ${metric} | ${budget}${metric.includes('Time') ? 'ms' : metric.includes('Size') ? ' bytes' : ' MB'} | ‚è≥ Pending |\n`;
  });
  
  return section;
}

/**
 * Generate recommendations section
 */
function generateRecommendationsSection(testResults: any, bundleResults: any): string {
  let recommendations = [];
  
  // Bundle size recommendations
  if (bundleResults.totals && !bundleResults.totals.withinBudget) {
    recommendations.push(`üî¥ **HIGH PRIORITY:** Reduce total bundle size by ${bundleResults.totals.overhead.toFixed(1)}KB`);
  }
  
  if (bundleResults.violations && bundleResults.violations.length > 0) {
    bundleResults.violations.forEach((violation: any) => {
      recommendations.push(`üü° **MEDIUM:** Optimize ${violation.name} to reduce ${violation.overhead.toFixed(1)}KB overhead`);
    });
  }
  
  // General recommendations
  recommendations.push('üü¢ **LOW:** Implement lazy loading for non-critical filter components');
  recommendations.push('üü¢ **LOW:** Set up continuous performance monitoring');
  recommendations.push('üü¢ **LOW:** Consider implementing virtual scrolling for large filter lists');
  
  return recommendations.join('\n\n');
}

/**
 * Generate raw data section
 */
function generateRawDataSection(logs: any[]): string {
  if (logs.length === 0) {
    return 'No performance logs available.';
  }
  
  return `
<details>
<summary>Performance Log Data (${logs.length} entries)</summary>

\`\`\`json
${JSON.stringify(logs, null, 2)}
\`\`\`

</details>
`;
}

/**
 * Analyze performance results and provide insights
 */
async function analyzePerformanceResults() {
  console.log('üîç Analyzing performance results...');
  
  const fs = require('fs');
  const path = require('path');
  
  try {
    // Read all performance data
    const perfDataDir = path.join(process.cwd(), 'performance-test-data');
    const analysisFile = path.join(perfDataDir, 'performance-analysis.json');
    
    const analysis = {
      timestamp: Date.now(),
      summary: {
        testsRun: true,
        bundleAnalyzed: fs.existsSync(path.join(process.cwd(), 'bundle-analysis-results.json')),
        lighthouseRun: fs.existsSync(path.join(process.cwd(), '.lighthouseci')),
        overallStatus: 'completed'
      },
      recommendations: [
        'Review bundle size optimization opportunities',
        'Monitor performance metrics in production',
        'Set up automated performance regression testing'
      ],
      nextSteps: [
        'Implement lazy loading for filter components',
        'Set up performance monitoring dashboard',
        'Create performance budget alerts'
      ]
    };
    
    fs.writeFileSync(analysisFile, JSON.stringify(analysis, null, 2));
    console.log('  ‚úì Performance analysis completed');
    
  } catch (error) {
    console.error('  ‚ùå Performance analysis failed:', error.message);
  }
}

/**
 * Clean up temporary data
 */
async function cleanupTempData() {
  console.log('üßπ Cleaning up temporary files...');
  
  // Currently keeping all data for review
  // In CI environment, might want to clean up some temporary files
  if (process.env.CI) {
    console.log('  ‚Ñπ Keeping performance data for CI artifact collection');
  } else {
    console.log('  ‚Ñπ Keeping performance data for local review');
  }
  
  console.log('  ‚úì Cleanup completed');
}

export default globalTeardown;